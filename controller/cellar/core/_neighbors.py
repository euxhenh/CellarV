from logging import log
import os

import faiss
import numpy as np
import pandas as pd
from app import logger
from numpy.core.fromnumeric import shape
from scipy.sparse import csr_matrix
from sklearn.neighbors import KDTree, kneighbors_graph

from ..utils.exceptions import InternalError, UserError


def full_knn(x, n_neighbors=15, mode='connectivity'):
    """
    Compute the exact nearest neighbors graph using sklearn.
    """
    kg = kneighbors_graph(x, n_neighbors=n_neighbors, mode=mode)
    sources, targets = kg.nonzero()
    weights = np.array(kg[sources, targets])[0]

    return sources, targets, weights


def faiss_knn(x, n_neighbors=15):
    """
    Compute approximate neighbors using the faiss library. We are using
    the CPU based release of faiss.
    """
    n_samples = x.shape[0]
    n_features = x.shape[1]
    x = np.ascontiguousarray(x)  # important

    index = faiss.IndexHNSWFlat(n_features, min(15, n_samples))
    index.add(x)

    weights, targets = index.search(x, n_neighbors)

    sources = np.repeat(np.arange(n_samples), n_neighbors)
    targets = targets.flatten()
    # weights = weights.flatten()

    if -1 in targets:
        raise InternalError("Not enough neighbors were found. Please consider "
                            "reducing the number of neighbors.")
    # TODO fix weights
    return sources, targets, np.full(len(sources), 1)


def knn_auto(x, n_neighbors=15, mode='connectivity', method='auto'):
    if method == 'auto':
        if x.shape[0] > 5000:
            print("Dataset is too large. Finding approximate neighbors.")
            return faiss_knn(x, n_neighbors=n_neighbors)
        return full_knn(x, n_neighbors=n_neighbors, mode=mode)
    elif method == 'full':
        return full_knn(x, n_neighbors=n_neighbors, mode=mode)

    return faiss_knn(x, n_neighbors=n_neighbors)


def get_spatial_knn_graph(
        path_to_df, n_neighbors=3, adata=None, key='spatial_nneigh'):
    """
    Constructs a nearest neighbors graph using CODEX spatial tiles
    and return a sparse adjacency matrix.

    Parameters
    __________
    path_to_df: string
        Path to data.csv as generated by cytokit.
        It must contain the columns 'rx', 'ry', 'rid' (optional)
        where 'rx' and 'ry' correspond to the x and y coordinates,
        while 'rid' contains the order of the cells in adata.
    n_neighbors: int
        Number of neighbors to compute.
    adata: anndata.AnnData object
    key: str
        If adata is not None, will use this key to store the adjacency
        matrix in adata.obsp

    Returns
    _______
    sparse.csr_matrix symmetric, binary adjacency matrix.
    If adata is not None, will also add the adjacency matrix to adata.obsp
    """
    if not os.path.exists(path_to_df):
        raise UserError("No data.csv file containing spatial info was found.")
    # Read dataframe
    data = pd.read_csv(path_to_df)
    # We will only be using x and y coordinates
    if 'rx' not in data or 'ry' not in data:
        raise UserError("data.csv contains incorrect columns. " +
                        "One of 'rx' or 'ry' not found.")
    x = data['rx'].to_numpy().astype(float)
    y = data['ry'].to_numpy().astype(float)
    # Just to make sure the order is ok
    if 'rid' in data:
        rid = data['rid'].to_numpy().astype(int)
        argind = np.argsort(rid)
        x, y = x[argind], y[argind]
    if x.shape[0] < adata.shape[0]:
        raise UserError("Incorrect shape for the coordinate matrix.")
    elif x.shape[0] > adata.shape[0]:
        logger.warn("Found more coordinates than samples. Truncating...")
        x, y = x[:adata.shape[0]], y[:adata.shape[0]]
    # Stack into a single data array
    coords = np.array([x, y]).T

    # Use a KD-Tree for fast neighbors computation
    kdt = KDTree(coords, leaf_size=5)
    if n_neighbors + 1 >= coords.shape[0]:
        logger.warn(f"Not enough samples found for f{n_neighbors}." +
                    f"Switching to f{coords.shape[0] // 2 + 1} neighbors.")
        n_neighbors = coords.shape[0] // 2 + 1
    # Add one neighbor since we do not want to include self
    nn_indices = kdt.query(coords, return_distance=False, k=n_neighbors + 1)
    nn_indices = nn_indices[:, 1:]  # Remove self
    # Construct sparse matrix from nn_indices
    n, d = nn_indices.shape
    x_cord = np.repeat(np.arange(n), d)
    adj = csr_matrix(
        (np.full(n * d, 1), (x_cord, nn_indices.flat)), shape=(n, n))
    adj = ((adj + adj.transpose()) > 0).astype(float)

    if adata is not None:
        adata.obsp[key] = adj
        adata.uns[key] = {
            'n_neighbors': n_neighbors
        }

    return adj
