from logging import log
import os

import faiss
import numpy as np
import pandas as pd
from app import logger
from numpy.core.fromnumeric import shape
from scipy.sparse import csr_matrix
from sklearn.neighbors import KDTree, kneighbors_graph

from ..utils.exceptions import InternalError, UserError


def full_knn(x, n_neighbors=15, mode='connectivity'):
    """
    Compute the exact nearest neighbors graph using sklearn.
    """
    kg = kneighbors_graph(x, n_neighbors=n_neighbors, mode=mode)
    sources, targets = kg.nonzero()
    weights = np.array(kg[sources, targets])[0]

    return sources, targets, weights


def faiss_knn(x, n_neighbors=15):
    """
    Compute approximate neighbors using the faiss library. We are using
    the CPU based release of faiss.
    """
    n_samples = x.shape[0]
    n_features = x.shape[1]
    x = np.ascontiguousarray(x)  # important

    index = faiss.IndexHNSWFlat(n_features, min(15, n_samples))
    index.add(x)

    weights, targets = index.search(x, n_neighbors)

    sources = np.repeat(np.arange(n_samples), n_neighbors)
    targets = targets.flatten()
    # weights = weights.flatten()

    if -1 in targets:
        raise InternalError("Not enough neighbors were found. Please consider "
                            "reducing the number of neighbors.")
    # TODO fix weights
    return sources, targets, np.full(len(sources), 1)


def knn_auto(x, n_neighbors=15, mode='connectivity', method='auto'):
    if method == 'auto':
        if x.shape[0] > 5000:
            print("Dataset is too large. Finding approximate neighbors.")
            return faiss_knn(x, n_neighbors=n_neighbors)
        return full_knn(x, n_neighbors=n_neighbors, mode=mode)
    elif method == 'full':
        return full_knn(x, n_neighbors=n_neighbors, mode=mode)

    return faiss_knn(x, n_neighbors=n_neighbors)


def _get_coordinates(rid, indices, x, y):
    """
    Matches the IDs in rid and adata.obs.index and returns the appropriate
    x and y coordinates. It will raise an error if adata contains
    any IDs not present in rid.
    """
    if rid.shape[0] < indices.shape[0]:
        raise UserError("Incorrect shape for the coordinate matrix. " +
                        "adata contains more samples.")
    elif rid.shape[0] > indices.shape[0]:
        logger.warn("Found more coordinates than samples. Truncating...")

    try:
        _, ind1, ind2 = np.intersect1d(
            rid, indices, return_indices=True)
        if ind2.shape[0] != indices.shape[0]:
            raise UserError("Some sample IDs were not found in data.csv.")
        # First limit x, y to overlap only
        x, y = x[ind1].copy(), y[ind1].copy()
        # Since np.intersect1d returns sorted values, we un-sort
        sorted_indices = np.argsort(indices)
        # Make sure to copy, since x will be updated online
        xx, yy = x.copy(), y.copy()
        x[sorted_indices], y[sorted_indices] = xx, yy
        logger.info(f"Kept {x.shape[0]} coordinates.")
    except UserError as ue:
        raise ue
    except Exception as e:
        raise InternalError(
            "An error occurred when parsing coordinates.")

    return x, y


def get_spatial_knn_graph(
        path_to_df, n_neighbors=3, adata=None, key='spatial_nneigh',
        is_truncated=False):
    """
    Constructs a nearest neighbors graph using CODEX spatial tiles
    and return a sparse adjacency matrix.

    Parameters
    __________
    path_to_df: string
        Path to data.csv as generated by cytokit.
        It must contain the columns 'rx', 'ry', 'rid'
        where 'rx' and 'ry' correspond to the x and y coordinates,
        while 'rid' contains the order of the cells in adata.
    n_neighbors: int
        Number of neighbors to compute.
    adata: anndata.AnnData object
    key: str
        If adata is not None, will use this key to store the adjacency
        matrix in adata.obsp
    is_truncated: bool
        If set to True, will assume that adata has been truncated and
        will not populate its neighbors keys.

    Returns
    _______
    sparse.csr_matrix symmetric, binary adjacency matrix.
    If adata is not None, will also add the adjacency matrix to adata.obsp
    """
    if not os.path.exists(path_to_df):
        raise UserError("No data.csv file containing spatial info was found.")
    # Read dataframe
    data = pd.read_csv(path_to_df)
    # We will only be using x and y coordinates
    if 'rx' not in data or 'ry' not in data:
        raise UserError("data.csv contains incorrect columns. " +
                        "One of 'rx' or 'ry' not found.")

    x = data['rx'].to_numpy().astype(float)
    y = data['ry'].to_numpy().astype(float)
    rid = data['rid'].to_numpy().astype(int)
    # Check shapes and get overlapping IDs
    if adata is not None:
        x, y = _get_coordinates(
            rid, adata.obs.index.to_numpy().astype(int), x, y)
    # Stack into a single data array
    coords = np.array([x, y]).T
    # Use a KD-Tree for fast neighbors computation
    kdt = KDTree(coords, leaf_size=5)
    if n_neighbors + 1 >= coords.shape[0]:
        logger.warn(f"Not enough samples found for f{n_neighbors}." +
                    f"Switching to f{coords.shape[0] // 2 + 1} neighbors.")
        n_neighbors = coords.shape[0] // 2 + 1
    # Add one neighbor since we do not want to include self
    nn_indices = kdt.query(coords, return_distance=False, k=n_neighbors + 1)
    nn_indices = nn_indices[:, 1:]  # Remove self
    # Construct sparse matrix from nn_indices
    n, d = nn_indices.shape
    x_cord = np.repeat(np.arange(n), d)
    adj = csr_matrix(
        (np.full(n * d, 1), (x_cord, nn_indices.flat)), shape=(n, n))
    adj = ((adj + adj.transpose()) > 0).astype(float)

    if adata is not None and not is_truncated:
        adata.obsp[key] = adj
        adata.uns[key] = {
            'n_neighbors': n_neighbors
        }

    return adj
